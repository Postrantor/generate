---
tip: translate by baidu@2023-10-25 08:21:51
---
---
metaTitle: "C++ | Callable Objects"
description: "Function Pointers, Classes with operator()  (Functors)"
---

# Callable Objects



Callable objects are the collection of all C++ structures which can be used as a function. In practice, this are all things you can pass to the C++17 STL function invoke() or which can be used in the constructor of std::function, this includes:

> 可调用对象是可以用作函数的所有C++结构的集合。在实践中，这些都是可以传递给C++17 STL函数invoke（）或可以在std：：函数的构造函数中使用的东西，包括：

Function pointers, Classes with operator(), Classes with implicit conversions, References to functions, Pointers to member functions, Pointers to member data, lambdas.

> 函数指针、带运算符（）的类、带隐式转换的类、对函数的引用、对成员函数的指针、对成员数据的指针、lambda。
The callable objects are used in many STL algorithms as predicate.



## Function Pointers



Function pointers are the most basic way of passing functions around, which can also be used in C. (See the [C documentation](http://stackoverflow.com/documentation/c/250/function-pointers) for more details).

> 函数指针是传递函数的最基本方式，也可以在C中使用(http://stackoverflow.com/documentation/c/250/function-pointers)了解更多详细信息）。


For the purpose of callable objects, a function pointer can be defined as:

> 对于可调用对象，函数指针可以定义为：

```cpp
typedef returnType(*name)(arguments);                       // All
using name = returnType(*)(arguments);                      // <= C++11
using name = std::add_pointer<returnType(arguments)>::type; // <= C++11
using name = std::add_pointer_t<returnType(arguments)>;     // <= C++14

```


If we would be using a function pointer for writing our own vector sort, it would look like:

> 如果我们使用函数指针来编写我们自己的向量排序，它看起来像：

```cpp
using LessThanFunctionPtr = std::add_pointer_t<bool(int, int)>;
void sortVectorInt(std::vector<int>&v, LessThanFunctionPtr lessThan) {
    if (v.size() < 2)
        return;
    if (v.size() == 2) {
        if (!lessThan(v.front(), v.back())) // Invoke the function pointer
            std::swap(v.front(), v.back());
        return;
    }
    std::sort(v, lessThan);
}

bool lessThanInt(int lhs, int rhs) { return lhs < rhs; }
sortVectorInt(vectorOfInt, lessThanInt); // Passes the pointer to a free function

struct GreaterThanInt {
   static bool cmp(int lhs, int rhs) { return lhs > rhs; }
};
sortVectorInt(vectorOfInt, &GreaterThanInt::cmp); // Passes the pointer to a static member function

```


Alternatively, we could have invoked the function pointer one of following ways:

> 或者，我们可以通过以下方式之一调用函数指针：

- `(*lessThan)(v.front(), v.back()) // All`
- `std::invoke(lessThan, v.front(), v.back()) // <= C++17`



## Classes with operator()  (Functors)



Every class which overloads the `operator()` can be used as a function object. These classes can be written by hand (often referred to as functors) or automatically generated by the compiler by writing [Lambdas](https://stackoverflow.com/documentation/c%2b%2b/572/lambdas) from C++11 on.

> 每个重载“operator（）”的类都可以用作函数对象。这些类可以手工编写（通常称为函子），也可以由编译器通过编写[Lambdas]自动生成(https://stackoverflow.com/documentation/c%2b%2b/572/lambdas)从C++11开始。

```cpp
struct Person {
    std::string name;
    unsigned int age;
};

// Functor which find a person by name
struct FindPersonByName {
    FindPersonByName(const std::string &name) : _name(name) {}

    // Overloaded method which will get called
    bool operator()(const Person &person) const {
         return person.name == _name;
    }
private:
    std::string _name;
};

std::vector<Person> v; // Assume this contains data
std::vector<Person>::iterator iFind =
    std::find_if(v.begin(), v.end(), FindPersonByName("Foobar"));
// ...

```


As functors have their own identity, they cannot be put in a typedef and these have to be accepted via template argument. The definition of `std::find_if` can look like:

> 由于函子有自己的身份，它们不能放在typedef中，必须通过模板参数来接受。“std:：find_if”的定义可以如下所示：

```cpp
template<typename Iterator, typename Predicate>
Iterator find_if(Iterator begin, Iterator end, Predicate &predicate) {
     for (Iterator i = begin, i != end, ++i)
         if (predicate(*i))
             return i;
     return end;
}

```


From C++17 on, the calling of the predicate can be done with invoke: `std::invoke(predicate, *i)`.

> 从C++17开始，谓词的调用可以使用invoke：`std:：invoke（谓词，*i）`完成。



#### Remarks



A very useful talk by Stephan T. Lavavej ([<functional>: What's New, And Proper Use](https://www.youtube.com/watch?v=zt7ThwVfap0)) ([Slides](https://github.com/CppCon/CppCon2015/blob/master/Presentations/functional%20-%20What%27s%20New%2C%20And%20Proper%20Usage/functional%20-%20What%27s%20New%2C%20And%20Proper%20Usage%20-%20Stephan%20T.%20Lavavej%20-%20CppCon%202015.pdf)) leads to the base of this documentation.

> Stephan T.Lavavej的一次非常有用的演讲(https://www.youtube.com/watch?v=zt7ThwVfap0))（[幻灯片](https://github.com/CppCon/CppCon2015/blob/master/Presentations/functional%20-%20什么%27s%20新%2C%20和%20正确%20用法/功能%20-%20What%27s+20新%2C%00和%20Proper%20用法%20-%20步骤%20T.%20Lavavej%20-%20CppCon%202015.pdf）导致了本文档的基础。

